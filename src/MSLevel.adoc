[[MSLevel]]
== Interrupts for Machine and Supervisor Levels

The RISC-V Privileged Architecture defines several major identities in the
range 0-15 for interrupts at a hart, including machine-level and
supervisor-level external interrupts (numbers 11 and 9), machine- and
supervisor-level timer interrupts (7 and 5), and machine- and
supervisor-level software interrupts (3 and 1). Beyond these major
labels, the _external_ interrupts at each privilege level are given
secondary, minor identities by an external interrupt controller such as
an APLIC or IMSIC, distinguishing interrupts from different devices or
causes. These minor identities for external interrupts were covered in
<<IMSIC>> and <<AdvPLIC>> specifying the IMSIC and APLIC components.

The Advanced Interrupt Architecture reserves another 24 major interrupt
identities for additional _local interrupts_ that arise within or in
close proximity to the hart, often for reporting errors. A mechanism is
also defined that allows software to selectively delegate both local and
custom interrupts to the next lower privilege level, or in some cases to
inject entirely virtual interrupts into a lower privilege level.

Lastly, an optional facility lets software assign priorities to major
interrupts (such as the timer and software interrupts, and any local
interrupts) such that they may mix with the priorities set for external
interrupts by a PLIC, APLIC, or IMSIC.

[[majorIntrs]]
=== Defined major interrupts and default priorities

<<TablemajorIntrs>> lists all the major interrupts
currently defined for harts that conform to this Advanced Interrupt
Architecture (AIA). Besides the major interrupts specified by the
RISC-V Privileged Architecture, the AIA adds interrupt numbers 35 and 43 as
local interrupts for low- and high-priority _RAS events_.

[[TablemajorIntrs]]
.The standard major interrupt codes, listed in default priority order
[%autowidth,%header,float="center",align="center",cols="1^,2<,3<"]
|===
|Default priority order |Major interrupt numbers ^|Description

.7+.<|Highest +
 +
 +
 +
 +
 +
 +
 +
Lowest
|43 |Local interrupt: high-priority RAS event
+<|11, 3, 7 +
9, 1, 5 +
12 +
10, 2, 6 +
13
+|Machine interrupts: external, software, timer +
Supervisor interrupts: external, software, timer +
Supervisor guest external interrupt +
VS interrupts: external, software, timer +
Local interrupt: counter overflow
|35 |Local interrupt: low-priority RAS event
|===

[[TablemajorIntrCategories]]
.Categorization of current and future major interrupts.
[%autowidth,float="center",align="center",cols="2<,3<"]
|===
|Major interrupt numbers ^|Category
|0-12 +
13-15|Not Local interrupts }  Assigned by the +
Local interrupts }      Privileged Architecture
<|16-23 +
24-31 +
32-47 +
&#8805; 48
|Local interrupts +
_Deisgnated for custom use_ +
Local interrupts +
_Designated for custom use_
|===

Of the major interrupts controlled by the Privileged Architecture
(numbers 0-15), the AIA categorizes the counter overflow interrupt
(code 13) as a _local interrupt_. It is assumed furthermore that any
future definitions for reserved interrupt numbers 14 and 15 will also be
local interrupts. Besides the two RAS interrupts, the AIA additionally
reserves major interrupt numbers in the ranges 16-23 and 32-47 for
standard local interrupts that other RISC-V extensions may define. The
remaining major interrupts allocated to the Privileged Architecture,
numbers 0-12, are categorized as not local interrupts. Taken altogether,
<<TablemajorIntrCategories>> summarizes the AIA's categorization of all major interrupt identities.

_RAS_ is an abbreviation for _Reliability, Availability, and
Serviceability_. Typically a RAS event corresponds to the detection of
corrupted data (e.g. as a result of a soft or hard error) and/or the use
of such data. The high-priority RAS event local interrupt may, for
example, signal an occurrence of an urgent uncorrected error that needs
action from a RAS error handler to contain the error and, if possible,
to recover from it. The low-priority RAS event local interrupt may, for
example, be triggered by non-urgent deferred or corrected errors.

The AIA does not itself require that detected RAS events trigger one of
the two local interrupts defined for this purpose. Systems are free to
report any or all RAS events another way, such as by external interrupts
routed through an APLIC or IMSIC, or by custom interrupts.

[NOTE]
====
In all likelihood, the method for reporting a particular RAS event will
depend on where in the system the event is detected. The AIA defines
local interrupt numbers for RAS events so systems have a standard way to
report such events when detected locally at a hart, without depending
solely on external or custom interrupts.

As always, platform standards may further constrain how a system reports
events, whether RAS events or other.

For the standard local interrupts not defined by the RISC-V Privileged
Architecture (numbers 16-23 and 32-47), the current plan is to assign
default priorities in the order shown in this table:

TODO: PUT TABLE HERE

Among interrupts 16-23, a higher interrupt number conveys higher default
priority, and likewise for interrupts 32-47. These two groups are
interleaved together in the complete order, and the Privileged
Architecture's standard interrupts, 0-15, are inserted into the middle
of the sequence. This proposed default priority order is arranged so
that interrupts 0-31 can potentially be an adequate subset on their own
for 32-bit RISC-V systems.

In actuality, future RISC-V extensions may or may not stick to this plan for
the default priority order of interrupts they define.

'''

In addition to the existing major interrupts of
<<TablemajorIntrs>>, the following local interrupts
are tentatively proposed, listed in order of decreasing default
priority:

 23 Bus or system error
 45 Per-core high-power or over-temperature event
 17 Debug/trace interrupt

These local interrupts are expected to be specified by other RISC-V extensions.
Be aware, this list is not final and may change as the relevant
extensions are developed and ratified.

'''

If a future version of the RISC-V Privileged Architecture defines interrupt 0,
the Advanced Interrupt Architecture needs it to have a default priority
lower than certain external interrupts. See <<mtopi>>
and <<stopi>> on CSRs `mtopi` and `stopi`.
====

Interrupt numbers 24-31 and 48 and higher are all designated for custom
use. If a hart implements any custom interrupts, their positions in the
default priority order must be documented for the hart.

[NOTE]
====
While many of the standard registers such as `mip` and `mie` have space for major
interrupts only in the range 0-63, custom interrupts with numbers 64 and
above are conceivable with added custom support. CSRs `mtopi`
(<<mtopi>>) and `stopi` (<<stopi>>) allow for
major interrupt numbers potentially as large as 4095.
====

When a hart supports the arbitrary configuration of interrupt priorities
by software (described in later sections), the default priority order
still remains relevant for breaking ties when two interrupt sources are
assigned the same priority number.

=== Interrupts at machine level

For whichever standard local interrupts are implemented, the
corresponding bits in CSRs and must be writable, and the corresponding
bits in (if that CSR exists because supervisor mode is implemented) must
each either be writable or be hardwired to zero. An occurrence of a
local interrupt event causes the interrupt-pending bit in to be set to
one. This bit then remains set until cleared by software.

As established by the Privileged Architecture, an interrupt traps to
M-mode whenever all of the following are true: (a) either the current
privilege mode is M-mode and machine-level interrupts are enabled by the
MIE bit of , or the current privilege mode has less privilege than
M-mode; (b) matching bits in and are both one; and (c) if exists, the
corresponding bit in is zero.

When multiple interrupt causes are ready to trigger simultaneously, the
interrupt taken first is determined by priority order, which may be the
default order specified in the previous section (#sec:majorIntrs[1.1]),
or may be a modified order configured by software.

[[sec:intrPrios-M]]
==== Configuring priorities of major interrupts at machine level

The machine-level priorities for major interrupts 0–63 may be configured
by a set of registers accessed through the and CSRs introduced in
Chapter #ch:CSRs[[ch:CSRs]]. When XLEN = 32, sixteen of these registers
are defined, listed below with their addresses:

& +
& +
…&  … +
& +

Each register controls the priorities of four interrupts, with one 8-bit
byte per interrupt. For a number latexmath:[$k$] in the range 0–15,
register latexmath:[$k$] controls the priorities of interrupts
latexmath:[$k\times\mbox{4}$] through
latexmath:[${k\times\mbox{4}+\mbox{3}}$], formatted as follows:

bits 7:0 & Priority number for interrupt latexmath:[$k\times\mbox{4}$] +
bits 15:8 & Priority number for interrupt
latexmath:[$k\times\mbox{4}+\mbox{1}$] +
bits 23:16 & Priority number for interrupt
latexmath:[$k\times\mbox{4}+\mbox{2}$] +
bits 31:24 & Priority number for interrupt
latexmath:[$k\times\mbox{4}+\mbox{3}$] +

When XLEN = 64, only the even-numbered registers exist:

& +
& +
…&  … +
& +

Each register controls the priorities of eight interrupts. For
even latexmath:[$k$] in the range 0–14, register latexmath:[$k$]
controls the priorities of interrupts latexmath:[$k\times\mbox{4}$]
through latexmath:[${k\times\mbox{4}+\mbox{7}}$], formatted as follows:

bits 7:0 & Priority number for interrupt latexmath:[$k\times\mbox{4}$] +
bits 15:8 & Priority number for interrupt
latexmath:[$k\times\mbox{4}+\mbox{1}$] +
bits 23:16 & Priority number for interrupt
latexmath:[$k\times\mbox{4}+\mbox{2}$] +
bits 31:24 & Priority number for interrupt
latexmath:[$k\times\mbox{4}+\mbox{3}$] +
bits 39:32 & Priority number for interrupt
latexmath:[$k\times\mbox{4}+\mbox{4}$] +
bits 47:40 & Priority number for interrupt
latexmath:[$k\times\mbox{4}+\mbox{5}$] +
bits 55:48 & Priority number for interrupt
latexmath:[$k\times\mbox{4}+\mbox{6}$] +
bits 63:56 & Priority number for interrupt
latexmath:[$k\times\mbox{4}+\mbox{7}$] +

When XLEN = 64 and is an odd value in the range –, attempting to access
raises an illegal instruction exception.

The valid registers – are known collectively as the _`iprio` array_ for
machine level.

The width of priority numbers for external interrupts is _IPRIOLEN_.
This parameter is affected by the main external interrupt controller for
the hart, whether a PLIC, APLIC, or IMSIC.

For an APLIC, IPRIOLEN is in the range 1–8 as specified in
Chapter #ch:AdvPLIC[[ch:AdvPLIC]] on the APLIC.

For an IMSIC, IPRIOLEN is 6, 7, or 8. IPRIOLEN may be 6 only if the
number of external interrupt identities implemented by the IMSIC is 63.
IPRIOLEN may be 7 only if the number of external interrupt identities
implemented by the IMSIC is no more than 127. IPRIOLEN may be 8 for any
IMSIC, regardless of the number of external interrupt identities
implemented.

Each byte of a valid latexmath:[$k$] register is either a read-only zero
or a unsigned integer field implementing exactly IPRIOLEN bits. For a
given interrupt number, if the corresponding bit in is read-only zero,
then the interrupt’s priority number in the array must be read-only zero
as well. The priority number for a machine-level external interrupt
(bits 31:24 of register ) must also be read-only zero. Aside from these
two restrictions, implementations may freely choose which priority
number fields are settable and which are read-only zeros. If all bytes
in the array are read-only zeros, priorities can be configured only for
external interrupts, not for any other interrupts.

Platform standards may require that priorities be configurable for
certain interrupt causes.

The array accessed via and affects the prioritization of interrupts only
when they trap to M-mode. When an interrupt’s priority number in the
array is zero (either read-only zero or set to zero), its priority is
the default order from Section #sec:majorIntrs[1.1]. Setting an
interrupt’s priority number instead to a nonzero value latexmath:[$p$]
gives that interrupt nominally the same priority as a machine-level
external interrupt with priority number latexmath:[$p$]. For a major
interrupt that defaults to a higher priority than machine external
interrupts, setting its priority number to a nonzero value _lowers_ its
priority. For a major interrupt that defaults to a lower priority than
machine external interrupts, setting its priority number to a nonzero
value _raises_ its priority. When two interrupt causes have been
assigned the same nominal priority, ties are broken by the default
priority order. Table #tab:intrPrios-M[[tab:intrPrios-M]] summarizes the
effect of priority numbers on interrupt priority.

[cols="^,^,^,^",]
|===
| |Interrupts with default |Machine external |Interrupts with default
| |priority above machine |interrupts |priority below machine
| |external interrupts | |external interrupts
| |Priority number in |Priority number from |Priority number in
|Priority |machine-level |interrupt controller |machine-level
|order |array |(APLIC or IMSIC) |array
|Highest |0 | |
| |1 |1 |1
| |2 |2 |2
| |latexmath:[$\cdots$] |latexmath:[$\cdots$] |latexmath:[$\cdots$]
| |254 |254 |254
| |255 |255 |255
| | |256 and above |
| | |(IMSIC only) |
|Lowest | | |0
|===

When a hart has an IMSIC supporting more than 255 minor identities for
external interrupts, the only non-default priorities that can be
configured for other interrupts are those corresponding to external
interrupt identities 1–255, not those of identities 256 or higher.

Implementing the priority configurability of this section requires that
a hart’s external interrupt controller communicate to the hart not only
the existence of a pending-and-enabled external interrupt but also the
interrupt’s priority number. Typically this implies that the width of
the connection for signaling an external interrupt to the hart is not
just a single wire as usual but now latexmath:[$\mbox{IPRIOLEN} + 1$]
wires.

It is expected that many systems will forego priority configurability of
major interrupts and simply have the array be all read-only zeros.
Systems that need this priority configurability can try to arrange for
each hart’s external interrupt controller to be relatively close to the
hart, by, for example, limiting the system to at most a few small cores
connected to an APLIC, or alternatively by giving every hart its own
IMSIC.

If supported, setting the priority number for supervisor-level external
interrupts (bits 15:8 of ) to a nonzero value latexmath:[$p$] has the
effect of giving the entire category of supervisor external interrupts
nominally the same priority as a machine external interrupt with
priority number latexmath:[$p$]. But note that this applies only to the
case when supervisor external interrupts trap to M-mode.

(Because supervisor guest external interrupts and VS-level external
interrupts are required to be delegated to supervisor level when the
hypervisor extension is implemented, the machine-level priority numbers
for these interrupts are always ignored and should be read-only zeros.)

If the system has an original PLIC for backward compatibility with older
software, reset should initialize the machine-level array to all zeros.

[[sec:mtopi]]
==== Machine top interrupt CSR ()

Machine-level CSR is read-only with width MXLEN. A read of returns
information about the highest-priority pending-and-enabled interrupt for
machine level, in this format:

bits 27:16 & IID +
bits 7:0 & IPRIO +

All other bits of are reserved and read as zeros.

The value of is zero unless there is an interrupt pending in and enabled
in that is not delegated to a lower privilege level. When there is a
pending-and-enabled major interrupt for machine level, field IID
(Interrupt Identity) is the major identity number of the
highest-priority interrupt, and field IPRIO indicates its priority.

If all bytes of the machine-level array are read-only zeros, a
simplified implementation of field IPRIO is allowed in which its value
is always 1 whenever is not zero.

Otherwise, when is not zero, if the priority number for the reported
interrupt is in the range 1 to 255, IPRIO is simply that number. If the
interrupt’s priority number is zero or greater than 255, IPRIO is set to
either 0 or 255 as follows:

* If the interrupt’s priority number is greater than 255, then IPRIO is
255 (lowest priority).
* If the interrupt’s priority number is zero and interrupt number IID
has a default priority higher than a machine external interrupt, then
IPRIO is 0 (highest priority).
* If the interrupt’s priority number is zero and interrupt number IID
has a default priority lower than a machine external interrupt, then
IPRIO is 255 (lowest priority).

To ensure that is never zero when an interrupt is pending and enabled
for machine level, if major interrupt 0 can trap to M-mode, it must have
a default priority lower than a machine external interrupt.

The value of is not affected by the global interrupt enable MIE in CSR .

The Privileged Architecture ensures that, when the value of is not zero,
a trap is taken to M-mode for the interrupt indicated by field IID if
either the current privilege mode is M and .MIE is one, or the current
privilege mode has less privilege than M-mode. The trap itself does not
cause the value of to change.

The following pseudocode shows how a machine-level trap handler might
read to avoid redundant restoring and saving of processor registers when
an interrupt arrives during the handling of another trap (either a
synchronous exception or an earlier interrupt):

save processor registers +
read CSR +
 +
handle synchronous exception +
restore if necessary +
 +
 +
loop +
read CSR +
exit loop +
 +
call the interrupt handler for major interrupt +
 +
 +
restore processor registers +
return from trap +

(This example can be further optimized, but with an increase in
complexity.)

[[sec:virtIntrs-S]]
=== Interrupt filtering and virtual interrupts for supervisor level

When supervisor mode is implemented, the Advanced Interrupt Architecture
adds a facility for software filtering of interrupts and for virtual
interrupts, making use of new CSRs (Machine Virtual Interrupt Enables)
and (Machine Virtual Interrupt-Pending bits). _Interrupt filtering_
permits a supervisor-level interrupt (SEI or SSI) or local or custom
interrupt to trap to M-mode and then be selectively delegated by
software to supervisor level, even while the corresponding bit in
remains zero. The same hardware may also, under the right circumstances,
allow machine level to assert _virtual interrupts_ to supervisor level
that have no connection to any real interrupt events.

Just as with CSRs , , and , each bit of registers and corresponds with
an interrupt number in the range 0–63. When a bit in is zero and the
matching bit in is one, then the same bit position in is an alias for
the corresponding bit in . A bit in is read-only zero when the
corresponding bits in and are both zero. The combined effects of and on
and are summarized in
Table #tab:intrFilteringForS[[tab:intrFilteringForS]].

[cols="^,^,^,^",options="header",]
|===
|latexmath:[$n$] |latexmath:[$n$] |latexmath:[$n$] |latexmath:[$n$]
|0 |0 |Read-only 0 |Read-only 0
|0 |1 |Alias of latexmath:[$n$] |Writable
|1 |– |Alias of latexmath:[$n$] |Alias of latexmath:[$n$]
|===

The name of CSR is not ``'' because the function of this register is
more analogous to than to . The bits of control whether the virtual
interrupt-pending bits in register are active and visible at supervisor
level. This is different than how the usual interrupt-enable bits (such
as in ) mask pending interrupts.

A bit in is writable if and only if the corresponding bit is set in
either or . When an interrupt is delegated by , the writable bit in is
an alias of the corresponding bit in ; else it is an independent
writable bit. As usual, bits that are not writable in must be read-only
zeros.

If a bit of is zero and the corresponding bit in is changed from zero to
one, then the value of the matching bit in becomes . Likewise, if a bit
of is one and the corresponding bit in is changed from one to zero, the
value of the matching bit in again becomes .

For interrupt numbers 13–63, implementations may freely choose which
bits of are writable and which bits are read-only zero or one. If such a
bit in is read-only zero (preventing the virtual interrupt from being
enabled), the same bit should be read-only zero in . All other bits for
interrupts 13–63 must be writable in .

Platform standards or other extensions may require that bits of for
certain interrupt causes be writable, or be read-only zero or one.

The bits of for supervisor software interrupts (code 1) and supervisor
external interrupts (code 9) are each either writable or read-only zero;
they cannot be read-only ones. The other bits of for interrupts 0–12 are
reserved and must be read-only zeros.

It is strongly recommended that bit 9 of be writable. Furthermore, if
bit 1 (SSIP) of can be set automatically by an interrupt controller and
not just by explicit writes to or , it is strongly recommended that
bit 1 of also be writable.

When bit 1 of is zero, bit 1 of is an alias of the same bit (SSIP) of .
But when bit 1 of is one, bit 1 of is a separate writable bit
independent of .SSIP. When the value of bit 1 of is changed from zero to
one, the value of bit 1 of becomes .

Bit 5 of is an alias of the same bit (STIP) in when that bit is writable
in . When STIP is not writable in (such as when .STCE = 1), bit 5 of is
read-only zero.

When bit 9 of is zero, bit 9 of is an alias of the software-writable
bit 9 of (SEIP). But when bit 9 of is one, bit 9 of is a writable bit
independent of .SEIP. Unlike for bit 1, changing the value of bit 9 of
does not affect the value of bit 9 of .

When bit 9 of is zero, bit 9 of makes the software-writable SEIP bit of
directly accessible by itself.

Except for bits 1, 5, and 9 as specified above, the bits of in the range
12:0 are reserved and must be read-only zeros.

The value of bit 9 of has some additional consequences for supervisor
external interrupts:

* When bit 9 of is zero, the software-writable SEIP bit (bit 9 of )
interacts with reads and writes of in the way specified by the
Privileged Architecture. In particular, for most purposes, the value of
bit 9 of is logically ORed into the readable value of .SEIP. But when
bit 9 of is one, bit SEIP in is read-only and does not include the value
of bit 9 of . Rather, the value of .SEIP is simply the supervisor
external interrupt signal from the hart’s external interrupt controller
(APLIC or IMSIC).
* If the hart has an IMSIC, then when bit 9 of is one, attempts from
S-mode to explicitly access the supervisor-level interrupt file raise an
illegal instruction exception. The exception is raised for attempts to
access CSR , or to access when has a value in the range –. Accesses to
guest interrupt files (through or + ) are not affected.

When the hypervisor extension is implemented, if a bit is zero in the
same position in both and , then that bit is read-only zero in (in
addition to being read-only zero in , , , and ). But if a bit for one of
interrupts 13–63 is a one in either or , then the same bit in may be
writable or may be read-only zero, depending on the implementation. No
bits in are ever read-only ones. The Privileged Architecture further
constrains bits 12:0 of .

When supervisor mode is implemented, the minimal required implementation
of and has all bits being read-only zeros except for bits 1 and 9, and
sometimes bit 5, each of which is an alias of an existing writable bit
in . (Although, as noted, it is strongly recommended that bit 9 of also
be writable.) When supervisor mode is not implemented, registers and do
not exist.

[[sec:intrs-S]]
=== Interrupts at supervisor level

If a standard local interrupt becomes pending (= 1) in , the bit in is
writable and will remain set until cleared by software.

Just as for machine level, the taking of interrupt traps at supervisor
level remains essentially the same as specified by the Privileged
Architecture. An interrupt traps into S-mode (or HS-mode) whenever all
of the following are true: (a) either the current privilege mode is
S-mode and supervisor-level interrupts are enabled by the SIE bit of ,
or the current privilege mode has less privilege than S-mode;
(b) matching bits in and are both one, or, if the hypervisor extension
is implemented, matching bits in and are both one; and (c) if the
hypervisor extension is implemented, the corresponding bit in is zero.

[[sec:intrPrios-S]]
==== Configuring priorities of major interrupts at supervisor level

Supervisor-level priorities for major interrupts 0–63 are optionally
configurable in an array of supervisor-level latexmath:[$k$] registers
accessed through and . This array has the same structure when XLEN = 32
or 64 as does the machine-level array. To summarize, when XLEN = 32,
there are sixteen 32-bit registers with these addresses:

& +
& +
…&  … +
& +

Each register controls the priorities of four interrupts, one 8-bit byte
per interrupt. When XLEN = 64, only the even-numbered registers exist:

& +
& +
…&  … +
& +

Each register controls the priorities of eight interrupts. If XLEN = 64
and is an odd value in the range –, attempting to access raises an
illegal instruction exception.

The valid registers – are known collectively as the _`iprio` array_ for
supervisor level. Each byte of a valid latexmath:[$k$] register is
either a read-only zero or a unsigned integer field implementing exactly
IPRIOLEN bits.

For a given interrupt number, if the corresponding bit in is read-only
zero, then the interrupt’s priority number in the supervisor-level array
must be read-only zero as well. The priority number for a
supervisor-level external interrupt (bits 15:8 of ) must also be
read-only zero. Aside from these two restrictions, implementations may
freely choose which priority number fields are settable and which are
read-only zeros.

As always, platform standards may require that priorities be
configurable for certain interrupt causes.

It is expected that many higher-end systems will not support the ability
to configure the priorities of major interrupts at supervisor level as
described in this section. Linux in particular is not designed to take
advantage of such facilities if provided. The array must be accessible
but may simply be all read-only zeros.

The supervisor-level array accessed via and affects the prioritization
of interrupts only when they trap to S-mode. When an interrupt’s
priority number in the array is zero (either read-only zero or set to
zero), its priority is the default order from
Section #sec:majorIntrs[1.1]. Setting an interrupt’s priority number
instead to a nonzero value latexmath:[$p$] gives that interrupt
nominally the same priority as a supervisor-level external interrupt
with priority number latexmath:[$p$]. For an interrupt that defaults to
a higher priority than supervisor external interrupts, setting its
priority number to a nonzero value lowers its priority. For an interrupt
that defaults to a lower priority than supervisor external interrupts,
setting its priority number to a nonzero value raises its priority. When
two interrupt causes have been assigned the same nominal priority, ties
are broken by the default priority order.
Table #tab:intrPrios-S[[tab:intrPrios-S]] summarizes the effect of
priority numbers on interrupt priority.

[cols="^,^,^,^",]
|===
| |Interrupts with default |Supervisor external |Interrupts with default
| |priority above supervisor |interrupts |priority below supervisor
| |external interrupts | |external interrupts
| |Priority number in |Priority number from |Priority number in
|Priority |supervisor-level |interrupt controller |supervisor-level
|order |array |(APLIC or IMSIC) |array
|Highest |0 | |
| |1 |1 |1
| |2 |2 |2
| |latexmath:[$\cdots$] |latexmath:[$\cdots$] |latexmath:[$\cdots$]
| |254 |254 |254
| |255 |255 |255
| | |256 and above |
| | |(IMSIC only) |
|Lowest | | |0
|===

If supported, setting the priority number for VS-level external
interrupts (bits 23:16 of ) to a nonzero value latexmath:[$p$] has the
effect of giving the entire category of VS external interrupts nominally
the same priority as a supervisor external interrupt with priority
number latexmath:[$p$], when VS external interrupts trap to S-mode.

If the system has an original PLIC for backward compatibility with older
software, reset should initialize the supervisor-level array to all
zeros.

[[sec:stopi]]
==== Supervisor top interrupt CSR ()

Supervisor-level CSR is read-only with width SXLEN. A read of returns
information about the highest-priority pending-and-enabled interrupt for
supervisor level, in this format:

bits 27:16 & IID +
bits 7:0 & IPRIO +

All other bits of are reserved and read as zeros.

The value of is zero unless: (a) there is an interrupt that is both
pending in and enabled in , or, if the hypervisor extension is
implemented, both pending in and enabled in ; and (b) the interrupt is
not delegated to a lower privilege level (by , if the hypervisor
extension is implemented). When there is a pending-and-enabled major
interrupt for supervisor level, field IID is the major identity number
of the highest-priority interrupt, and field IPRIO indicates its
priority.

If all bytes of the supervisor-level array are read-only zeros, a
simplified implementation of field IPRIO is allowed in which its value
is always 1 whenever is not zero.

Otherwise, when is not zero, if the priority number for the reported
interrupt is in the range 1 to 255, IPRIO is simply that number. If the
interrupt’s priority number is zero or greater than 255, IPRIO is set to
either 0 or 255 as follows:

* If the interrupt’s priority number is greater than 255, then IPRIO is
255 (lowest priority).
* If the interrupt’s priority number is zero and interrupt number IID
has a default priority higher than a supervisor external interrupt, then
IPRIO is 0 (highest priority).
* If the interrupt’s priority number is zero and interrupt number IID
has a default priority lower than a supervisor external interrupt, then
IPRIO is 255 (lowest priority).

To ensure that is never zero when an interrupt is pending and enabled
for supervisor level, if major interrupt 0 can trap to S-mode, it must
have a default priority lower than a supervisor external interrupt.

The value of is not affected by the global interrupt enable SIE in CSR .

The Privileged Architecture ensures that, when the value of is not zero,
a trap is taken to S-mode for the interrupt indicated by field IID if
either the current privilege mode is S and .SIE is one, or the current
privilege mode has less privilege than S-mode. The trap itself does not
cause the value of to change.

The following pseudocode shows how a supervisor-level trap handler might
read to avoid redundant restoring and saving of processor registers when
an interrupt arrives during the handling of another trap (either a
synchronous exception or an earlier interrupt):

save processor registers +
read CSR +
 +
handle synchronous exception +
restore if necessary +
 +
 +
loop +
read CSR +
exit loop +
 +
call the interrupt handler for major interrupt +
 +
 +
restore processor registers +
return from trap +

(This example can be further optimized, but with an increase in
complexity.)

=== WFI (Wait for Interrupt) instruction

The Privileged Architecture specifies that instruction WFI (Wait for
Interrupt) may suspend execution at a hart until an interrupt is pending
for the hart. The Advanced Interrupt Architecture (AIA) redefines when
execution must resume following a WFI.

According to the Privileged Architecture, instruction execution must
resume from a WFI whenever any interrupt is both pending and enabled in
CSRs and , ignoring any delegation indicated by . With the AIA, this
succinct rule is no longer appropriate, due to the mechanisms the AIA
adds for virtual interrupts. Instead, execution must resume from a WFI
whenever an interrupt is pending at any privilege level (regardless of
whether the interrupt privilege level is higher or lower than the hart’s
current privilege mode).

An interrupt is pending at machine level if register is not zero. If
S-mode is implemented, an interrupt is pending at supervisor level if is
not zero. And if the hypervisor extension is implemented, an interrupt
is pending at VS level if (Section #sec:vstopi[[sec:vstopi]]) is not
zero.

The AIA’s rule for WFI gives the same behavior as the Privileged
Architecture’s rule when = 0 and, if the hypervisor extension is
implemented, also = 0 and .VTI = 0, thus disabling all virtual
interrupts not visible in . (The AIA’s hypervisor registers are covered
in the next chapter, ``Interrupts for Virtual Machines (VS Level)''.)
